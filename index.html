<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <link rel="apple-touch-icon" href="icon.png">
    <title>RunRecord Pro</title>
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Flex:wght@400;800&family=Markazi+Text:wght@700&family=Fugaz+One&family=Shadows+Into+Light+Two&family=Michroma&family=Orbitron:wght@700;900&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <style>
        :root { --bg-color: #101012; --card-bg: #1c1c1e; --toss-blue: #3182f6; --text-main: #ffffff; --text-sub: #adb5bd; --danger: #ff3b30; }
        body { background: var(--bg-color); color: var(--text-main); font-family: -apple-system, sans-serif; display: flex; flex-direction: column; align-items: center; padding: 10px 0; margin: 0; min-height: 100vh; }
        #canvas-container { position: relative; width: 340px; height: 604px; background: var(--card-bg); border-radius: 30px; overflow: hidden; box-shadow: 0 20px 50px rgba(0,0,0,0.5); border: 1px solid #2c2c2e; cursor: move; touch-action: none; flex-shrink: 0; margin-top: 10px; }
        canvas { width: 100%; height: 100%; display: block; }
        .action-zone { width: 100%; max-width: 340px; padding: 10px 20px 0 20px; box-sizing: border-box; display: flex; flex-direction: column; }
        #status { font-size: 12px; color: var(--toss-blue); text-align: center; height: 15px; margin-bottom: 8px; font-weight: bold; }
        .btn-row { display: flex; gap: 8px; width: 100%; }
        button { border: none; cursor: pointer; transition: 0.2s; color: white; font-weight: 700; }
        #recordBtn { background: var(--toss-blue); padding: 16px; font-size: 15px; border-radius: 14px; flex: 1.5; }
        .preview-btn { background: #3a3a3c; padding: 16px; font-size: 15px; border-radius: 14px; flex: 1; }
        .tab-container { display: flex; width: 100%; max-width: 340px; padding: 20px 20px 10px 20px; box-sizing: border-box; gap: 10px; }
        .tab-btn { flex: 1; background: transparent; padding: 10px; font-size: 14px; color: #666; border-bottom: 2px solid #333; border-radius: 0; }
        .tab-btn.active { color: var(--toss-blue); border-bottom: 2px solid var(--toss-blue); }
        .controls-wrapper { width: 100%; max-width: 340px; padding: 0 20px 50px 20px; box-sizing: border-box; }
        .tab-content { display: none; flex-direction: column; gap: 12px; }
        .tab-content.active { display: flex; }
        .input-group { background: var(--card-bg); padding: 14px 18px; border-radius: 18px; display: flex; flex-direction: column; }
        .input-group label { font-size: 11px; color: var(--text-sub); margin-bottom: 6px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.5px; }
        select, input { background: transparent; border: none; color: white; font-size: 17px; outline: none; padding: 2px 0; width: 100%; }
        .opt-btn { background: #3a3a3c; padding: 12px; border-radius: 12px; font-size: 12px; flex: 1; }
        .opt-btn.active { background: var(--toss-blue); }
        .reset-btn { background: #2c2c2e; color: var(--danger); border: 1px solid #3a3a3c; font-size: 11px; padding: 12px; border-radius: 12px; }
        .drag-info { font-size: 11px; color: #555; text-align: center; margin-bottom: 5px; }
        .version-tag { font-size: 10px; color: #333; margin: 20px 0 40px 0; }
    </style>
</head>
<body>
    <div class="drag-info">üí° Í∏ÄÏûêÎ•º ÎìúÎûòÍ∑∏ÌïòÍ±∞ÎÇò Ï†ïÎ†¨ Î≤ÑÌäºÏùÑ ÎàåÎü¨ ÏúÑÏπòÎ•º Ïû°ÏúºÏÑ∏Ïöî!</div>
    <div id="canvas-container"><canvas id="runCanvas"></canvas></div>
    
    <div class="action-zone">
        <div id="status"></div>
        <div class="btn-row">
            <button class="preview-btn" onclick="runAnimation(false)">Preview</button>
            <button id="recordBtn" onclick="runAnimation(true)">Save (.mp4)</button>
        </div>
    </div>

    <div class="tab-container">
        <button class="tab-btn active" onclick="switchTab('data', this)">RECORD DATA</button>
        <button class="tab-btn" onclick="switchTab('design', this)">DESIGN</button>
    </div>

    <div class="controls-wrapper">
        <div id="data-tab" class="tab-content active">
            <div class="input-group"><label>Distance (KM)</label><input type="number" id="distInput" placeholder="0.00" step="0.01"></div>
            <div class="input-group"><label>Avg. Pace (ex. 552)</label><input type="text" id="paceInput" placeholder="555"></div>
            <div class="input-group"><label>Time (ex. 010000)</label><input type="text" id="timeInput" placeholder="000000"></div>
        </div>

        <div id="design-tab" class="tab-content">
            <input type="file" id="imageInput" accept="image/*" style="color: #888; font-size: 12px; margin-bottom: 5px;">
            <div class="input-group">
                <label>Photo Overlay (Darkness)</label>
                <div class="btn-row">
                    <button class="opt-btn ov-btn active" onclick="setOverlay(0, this)">0</button>
                    <button class="opt-btn ov-btn" onclick="setOverlay(0.2, this)">1</button>
                    <button class="opt-btn ov-btn" onclick="setOverlay(0.4, this)">2</button>
                    <button class="opt-btn ov-btn" onclick="setOverlay(0.6, this)">3</button>
                    <button class="opt-btn ov-btn" onclick="setOverlay(0.75, this)">4</button>
                </div>
            </div>
            <div class="input-group">
                <label>Alignment & Size</label>
                <div class="btn-row" style="margin-bottom:8px;">
                    <button class="opt-btn align-btn active" onclick="setAlign('left', this)">Left</button>
                    <button class="opt-btn align-btn" onclick="setAlign('center', this)">Center</button>
                    <button class="opt-btn align-btn" onclick="setAlign('right', this)">Right</button>
                </div>
                <div class="btn-row">
                    <button class="opt-btn size-btn" onclick="setSize(0.7, this)">Small</button>
                    <button class="opt-btn size-btn active" onclick="setSize(1.0, this)">Med</button>
                    <button class="opt-btn size-btn" onclick="setSize(1.3, this)">Large</button>
                    <button class="reset-btn" onclick="resetToDefault()">Reset</button>
                </div>
            </div>
            <div class="input-group">
                <label>Font Style</label>
                <select id="fontSelect" onchange="draw(displayData.distance)">
                    <option value="-apple-system">San Francisco</option>
                    <option value="'Orbitron'">Orbitron</option>
                    <option value="'Roboto Flex'">Roboto Flex</option>
                    <option value="'Fugaz One'">Fugaz One</option>
                    <option value="'Michroma'">Michroma</option>
                </select>
            </div>
        </div>
    </div>
    <div class="version-tag">v1.5</div>

<script>
    const canvas = document.getElementById('runCanvas');
    const ctx = canvas.getContext('2d');
    canvas.width = 1080; canvas.height = 1920;

    let bgImage = null;
    let displayData = { distance: 0 };
    let textAlign = 'left'; 
    let textSizeScale = 1.0;
    let overlayAlpha = 0; 
    let textPos = { x: 100, y: 1300 }; 
    let isDragging = false;

    function switchTab(tabName, btn) {
        document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
        document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
        btn.classList.add('active');
        document.getElementById(tabName + '-tab').classList.add('active');
    }

    function resetToDefault() {
        textAlign = 'left'; textSizeScale = 1.0; textPos = { x: 100, y: 1300 }; overlayAlpha = 0;
        document.querySelectorAll('.align-btn').forEach(b => b.classList.toggle('active', b.innerText === 'Left'));
        document.querySelectorAll('.size-btn').forEach(b => b.classList.toggle('active', b.innerText === 'Med'));
        document.querySelectorAll('.ov-btn').forEach(b => b.classList.toggle('active', b.innerText === '0'));
        draw(displayData.distance);
    }

    // [ÌïµÏã¨ Î≥ÄÍ≤Ω] Ï†ïÎ†¨ Î≤ÑÌäº ÌÅ¥Î¶≠ Ïãú Ï¢åÌëú Í∞ïÏ†ú Ïù¥Îèô
    function setAlign(align, btn) {
        textAlign = align;
        document.querySelectorAll('.align-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');

        // Ï†ïÎ†¨ Í∞íÏóê Îî∞Îùº X Ï¢åÌëú ÏûêÎèô Î∞∞Ïπò (Canvas Í∞ÄÎ°ú 1080 Í∏∞Ï§Ä)
        if (align === 'left') textPos.x = 100;
        else if (align === 'center') textPos.x = 540;
        else if (align === 'right') textPos.x = 980;

        draw(displayData.distance);
    }

    const container = document.getElementById('canvas-container');
    const handleStart = () => { isDragging = true; };
    const handleEnd = () => { isDragging = false; };
    const handleMove = (e) => {
        if (!isDragging) return;
        if (e.cancelable) e.preventDefault();
        const rect = canvas.getBoundingClientRect();
        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
        const clientY = e.touches ? e.touches[0].clientY : e.clientY;
        textPos.x = (clientX - rect.left) * (canvas.width / rect.width);
        textPos.y = (clientY - rect.top) * (canvas.height / rect.height);
        draw(displayData.distance);
    };

    container.addEventListener('mousedown', handleStart);
    window.addEventListener('mouseup', handleEnd);
    window.addEventListener('mousemove', handleMove);
    container.addEventListener('touchstart', handleStart, { passive: true });
    window.addEventListener('touchend', handleEnd);
    container.addEventListener('touchmove', handleMove, { passive: false });

    function setSize(scale, btn) {
        textSizeScale = scale;
        document.querySelectorAll('.size-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        draw(displayData.distance);
    }

    function setOverlay(alpha, btn) {
        overlayAlpha = alpha;
        document.querySelectorAll('.ov-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        draw(displayData.distance);
    }

    function formatPace(val) {
        if (!val) return "0'00\"";
        let n = val.replace(/\D/g, '');
        return n.length >= 3 ? `${n.slice(0, n.length-2)}'${n.slice(n.length-2)}"` : n;
    }

    function formatTime(val) {
        if (!val) return "00:00";
        let n = val.replace(/\D/g, '');
        if (n.length === 6) return `${n.slice(0,2)}:${n.slice(2,4)}:${n.slice(4,6)}`;
        if (n.length === 4) return `${n.slice(0,2)}:${n.slice(2,4)}`;
        return val;
    }

    function draw(dist = 0) {
        const font = document.getElementById('fontSelect').value;
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        if (bgImage) {
            const scale = Math.max(canvas.width / bgImage.width, canvas.height / bgImage.height);
            const x = (canvas.width / 2) - (bgImage.width / 2) * scale;
            const y = (canvas.height / 2) - (bgImage.height / 2) * scale;
            ctx.drawImage(bgImage, x, y, bgImage.width * scale, bgImage.height * scale);
            if (overlayAlpha > 0) {
                ctx.fillStyle = `rgba(0,0,0,${overlayAlpha})`;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }
            let grad = ctx.createLinearGradient(0, textPos.y + 500, 0, textPos.y - 300);
            grad.addColorStop(0, "rgba(0,0,0,0.8)");
            grad.addColorStop(1, "rgba(0,0,0,0)");
            ctx.fillStyle = grad; ctx.fillRect(0, 0, canvas.width, canvas.height);
        } else {
            ctx.fillStyle = "#1c1c1e"; ctx.fillRect(0, 0, canvas.width, canvas.height);
        }

        const dSize = 180 * textSizeScale;
        const unitSize = 60 * textSizeScale;
        const labelSize = 40 * textSizeScale;
        const subValueSize = 75 * textSizeScale;
        const spacing = 25 * textSizeScale;
        const dText = dist.toFixed(2);
        
        ctx.font = `bold ${dSize}px ${font}`;
        const dWidth = ctx.measureText(dText).width;
        ctx.font = `600 ${unitSize}px ${font}`;
        const uWidth = ctx.measureText("km").width;
        const totalDistWidth = dWidth + spacing + uWidth;

        let currentX = textPos.x;
        ctx.textAlign = textAlign;
        ctx.fillStyle = "rgba(255,255,255,0.7)";
        ctx.font = `500 ${labelSize}px ${font}`;
        ctx.fillText("Distance", currentX, textPos.y - (175 * textSizeScale));

        let distStartX = currentX;
        if (textAlign === 'center') distStartX = currentX - (totalDistWidth / 2);
        else if (textAlign === 'right') distStartX = currentX - totalDistWidth;

        ctx.textAlign = "left"; ctx.fillStyle = "white";
        ctx.font = `bold ${dSize}px ${font}`;
        ctx.fillText(dText, distStartX, textPos.y);
        ctx.font = `600 ${unitSize}px ${font}`;
        ctx.fillText("km", distStartX + dWidth + spacing, textPos.y);

        const pace = formatPace(document.getElementById('paceInput').value);
        const time = formatTime(document.getElementById('timeInput').value);
        ctx.textAlign = textAlign;
        ctx.font = `500 ${labelSize}px ${font}`; ctx.fillStyle = "rgba(255,255,255,0.7)";
        ctx.fillText("Avg. Pace", currentX, textPos.y + (100 * textSizeScale));
        ctx.fillStyle = "white"; ctx.font = `bold ${subValueSize}px ${font}`;
        ctx.fillText(pace, currentX, textPos.y + (185 * textSizeScale));
        ctx.font = `500 ${labelSize}px ${font}`; ctx.fillStyle = "rgba(255,255,255,0.7)";
        ctx.fillText("Time", currentX, textPos.y + (285 * textSizeScale));
        ctx.fillStyle = "white"; ctx.font = `bold ${subValueSize}px ${font}`;
        ctx.fillText(time, currentX, textPos.y + (370 * textSizeScale));
    }

    document.getElementById('distInput').oninput = (e) => { displayData.distance = parseFloat(e.target.value) || 0; draw(displayData.distance); };
    document.getElementById('paceInput').oninput = () => draw(displayData.distance);
    document.getElementById('timeInput').oninput = () => draw(displayData.distance);
    document.getElementById('imageInput').onchange = (e) => {
        const reader = new FileReader();
        reader.onload = (ev) => { const img = new Image(); img.onload = () => { bgImage = img; draw(displayData.distance); }; img.src = ev.target.result; };
        reader.readAsDataURL(e.target.files[0]);
    };

    async function runAnimation(isRecord = false) {
        const target = parseFloat(document.getElementById('distInput').value) || 0;
        const status = document.getElementById('status');
        displayData.distance = 0;
        let recorder = null; let chunks = [];
        if (isRecord) {
            status.innerText = "üé¨ Recording...";
            const stream = canvas.captureStream(30);
            let options = { mimeType: 'video/mp4' };
            if (!MediaRecorder.isTypeSupported('video/mp4')) options = { mimeType: 'video/webm' };
            recorder = new MediaRecorder(stream, options);
            recorder.ondataavailable = e => chunks.push(e.data);
            recorder.onstop = () => {
                const blob = new Blob(chunks, { type: options.mimeType });
                const a = document.createElement('a'); a.href = URL.createObjectURL(blob);
                a.download = `run_${new Date().getTime()}.mp4`; a.click();
                status.innerText = "‚úÖ Saved!";
                setTimeout(() => { status.innerText = ""; }, 3000);
            };
            recorder.start();
        }
        gsap.to(displayData, {
            distance: target, duration: 5.5, ease: "power4.out",
            onUpdate: () => draw(displayData.distance),
            onComplete: () => { if (isRecord) recorder.stop(); }
        });
    }
    draw();
</script>
</body>
</html>
